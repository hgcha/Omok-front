{"ast":null,"code":"export default function decideWinner(previousStonePosition, board) {\n  if (previousStonePosition.row === null && previousStonePosition.col === null) return;\n  let startPoints = [\n  //Checking horizontal line\n  {\n    row: previousStonePosition.row,\n    col: Math.max(0, previousStonePosition.col - 4)\n  },\n  //Checking vertical line\n  {\n    row: Math.max(0, previousStonePosition.row - 4),\n    col: previousStonePosition.col\n  },\n  //Checking \\ diagonal line\n  {\n    row: Math.max(0, previousStonePosition.row - 4),\n    col: Math.max(0, previousStonePosition.col - 4)\n  },\n  //Checking / diagonal line\n  {\n    row: Math.max(0, previousStonePosition.row - 4),\n    col: Math.min(18, previousStonePosition.col + 4)\n  }];\n  let endPoints = [\n  //Checking horizontal line\n  {\n    row: previousStonePosition.row,\n    col: Math.min(18, previousStonePosition.col + 4)\n  },\n  //Checking vertical line\n  {\n    row: Math.min(18, previousStonePosition.row + 4),\n    col: previousStonePosition.col\n  },\n  //Checking \\ diagonal line\n  {\n    row: Math.min(18, previousStonePosition.row + 4),\n    col: Math.min(18, previousStonePosition.col + 4)\n  },\n  //Checking / diagonal line\n  {\n    row: Math.min(18, previousStonePosition.row + 4),\n    col: Math.max(0, previousStonePosition.col - 4)\n  }];\n  let move = [[0, 1], [1, 0], [1, 1], [1, -1]];\n  for (let i = 0; i < 4; i++) {\n    let row = startPoints[i].row;\n    let col = startPoints[i].col;\n    let dr = move[i][0];\n    let dc = move[i][1];\n    let maxCount = 0;\n    let count = 0;\n    let length = Math.max(endPoints[i].row - startPoints[i].row, endPoints[i].col - startPoints[i].col) + 1;\n    for (let j = 0; j < length; j++) {\n      if (board[row][col] === board[previousStonePosition.row][previousStonePosition.col]) {\n        count++;\n        maxCount = Math.max(maxCount, count);\n      } else {\n        count = 0;\n      }\n      row += dr;\n      col += dc;\n    }\n    if (maxCount === 5) {\n      return board[previousStonePosition.row][previousStonePosition.col];\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["decideWinner","previousStonePosition","board","row","col","startPoints","Math","max","min","endPoints","move","i","dr","dc","maxCount","count","length","j"],"sources":["C:/Users/HyungGeun/Documents/omok-front/src/decideWinner.js"],"sourcesContent":["export default function decideWinner(previousStonePosition, board) {\r\n\r\n    if(previousStonePosition.row === null && previousStonePosition.col === null)\r\n        return;\r\n\r\n    let startPoints = [\r\n        //Checking horizontal line\r\n        {\r\n            row: previousStonePosition.row,\r\n            col: Math.max(0, previousStonePosition.col - 4)\r\n        },\r\n        //Checking vertical line\r\n        {\r\n            row: Math.max(0, previousStonePosition.row - 4),\r\n            col: previousStonePosition.col\r\n        },\r\n        //Checking \\ diagonal line\r\n        {\r\n            row: Math.max(0, previousStonePosition.row - 4),\r\n            col: Math.max(0, previousStonePosition.col - 4)\r\n        },\r\n        //Checking / diagonal line\r\n        {\r\n            row: Math.max(0, previousStonePosition.row - 4),\r\n            col: Math.min(18, previousStonePosition.col + 4)\r\n        }\r\n    ];\r\n\r\n    let endPoints = [\r\n        //Checking horizontal line\r\n        {\r\n            row: previousStonePosition.row,\r\n            col: Math.min(18, previousStonePosition.col + 4)\r\n        },\r\n        //Checking vertical line\r\n        {\r\n            row: Math.min(18, previousStonePosition.row + 4),\r\n            col: previousStonePosition.col\r\n        },\r\n        //Checking \\ diagonal line\r\n        {\r\n            row: Math.min(18, previousStonePosition.row + 4),\r\n            col: Math.min(18, previousStonePosition.col + 4)\r\n        },\r\n        //Checking / diagonal line\r\n        {\r\n            row: Math.min(18, previousStonePosition.row + 4),\r\n            col: Math.max(0, previousStonePosition.col - 4)\r\n        }\r\n    ];\r\n\r\n    let move = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [1, 1],\r\n        [1, -1]\r\n    ];\r\n\r\n    for(let i = 0; i < 4; i++) {\r\n        let row = startPoints[i].row;\r\n        let col = startPoints[i].col;\r\n        let dr = move[i][0];\r\n        let dc = move[i][1];\r\n        let maxCount = 0;\r\n        let count = 0;\r\n        let length = Math.max(endPoints[i].row - startPoints[i].row, endPoints[i].col - startPoints[i].col) + 1;\r\n\r\n        for(let j = 0; j < length; j++) {\r\n            if(board[row][col] === board[previousStonePosition.row][previousStonePosition.col]) {\r\n                count++;\r\n                maxCount = Math.max(maxCount, count);\r\n            } else {\r\n                count = 0;\r\n            }\r\n    \r\n            row += dr;\r\n            col += dc;           \r\n        }\r\n\r\n        if(maxCount === 5) {\r\n            return board[previousStonePosition.row][previousStonePosition.col];\r\n        }\r\n    }\r\n\r\n    return null;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}