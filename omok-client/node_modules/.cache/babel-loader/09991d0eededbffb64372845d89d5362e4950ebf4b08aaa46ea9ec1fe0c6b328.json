{"ast":null,"code":"export default function decideWinner(previousStonePosition, board) {\n  console.log(board);\n  let startPoints = [\n  //Checking horizontal line\n  {\n    row: previousStonePosition.row,\n    col: Math.max(0, previousStonePosition.col - 4)\n  },\n  //Checking vertical line\n  {\n    row: Math.max(0, previousStonePosition.row - 4),\n    col: previousStonePosition.col\n  },\n  //Checking \\ diagonal line\n  {\n    row: Math.max(0, previousStonePosition.row - 4),\n    col: Math.max(0, previousStonePosition.col - 4)\n  },\n  //Checking / diagonal line\n  {\n    row: Math.max(0, previousStonePosition.row - 4),\n    col: Math.min(18, previousStonePosition.col + 4)\n  }];\n  let endPoints = [\n  //Checking horizontal line\n  {\n    row: previousStonePosition.row,\n    col: Math.min(18, previousStonePosition.col + 4)\n  },\n  //Checking vertical line\n  {\n    row: Math.min(18, previousStonePosition.row + 4),\n    col: previousStonePosition.col\n  },\n  //Checking \\ diagonal line\n  {\n    row: Math.min(18, previousStonePosition.row + 4),\n    col: Math.min(18, previousStonePosition.col + 4)\n  },\n  //Checking / diagonal line\n  {\n    row: Math.min(18, previousStonePosition.row + 4),\n    col: Math.max(0, previousStonePosition.col - 4)\n  }];\n  let move = [[0, 1], [1, 0], [1, 1], [-1, 1]];\n  for (let i = 0; i < 4; i++) {\n    let row = startPoints[i].row;\n    let col = startPoints[i].col;\n    let dr = move[i][0];\n    let dc = move[i][1];\n    let count = 0;\n    let length = Math.max(endPoints[i].row - startPoints[i].row, endPoints[i].col - startPoints[i].col) + 1;\n    for (let j = 0; j < length; j++) {\n      if (board[row][col] === board[previousStonePosition.row][previousStonePosition.col]) {\n        count++;\n      } else {\n        count = 0;\n      }\n      if (count === 5) {\n        return board[previousStonePosition.row][previousStonePosition.col];\n      } else {\n        row += dr;\n        col += dc;\n      }\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["decideWinner","previousStonePosition","board","console","log","startPoints","row","col","Math","max","min","endPoints","move","i","dr","dc","count","length","j"],"sources":["C:/Users/HyungGeun/Documents/omok-front/src/decideWinner.js"],"sourcesContent":["export default function decideWinner(previousStonePosition, board) {\r\n\r\n    console.log(board);\r\n\r\n    let startPoints = [\r\n        //Checking horizontal line\r\n        {\r\n            row: previousStonePosition.row,\r\n            col: Math.max(0, previousStonePosition.col - 4)\r\n        },\r\n        //Checking vertical line\r\n        {\r\n            row: Math.max(0, previousStonePosition.row - 4),\r\n            col: previousStonePosition.col\r\n        },\r\n        //Checking \\ diagonal line\r\n        {\r\n            row: Math.max(0, previousStonePosition.row - 4),\r\n            col: Math.max(0, previousStonePosition.col - 4)\r\n        },\r\n        //Checking / diagonal line\r\n        {\r\n            row: Math.max(0, previousStonePosition.row - 4),\r\n            col: Math.min(18, previousStonePosition.col + 4)\r\n        }\r\n    ];\r\n\r\n    let endPoints = [\r\n        //Checking horizontal line\r\n        {\r\n            row: previousStonePosition.row,\r\n            col: Math.min(18, previousStonePosition.col + 4)\r\n        },\r\n        //Checking vertical line\r\n        {\r\n            row: Math.min(18, previousStonePosition.row + 4),\r\n            col: previousStonePosition.col\r\n        },\r\n        //Checking \\ diagonal line\r\n        {\r\n            row: Math.min(18, previousStonePosition.row + 4),\r\n            col: Math.min(18, previousStonePosition.col + 4)\r\n        },\r\n        //Checking / diagonal line\r\n        {\r\n            row: Math.min(18, previousStonePosition.row + 4),\r\n            col: Math.max(0, previousStonePosition.col - 4)\r\n        }\r\n    ];\r\n\r\n    let move = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [1, 1],\r\n        [-1, 1]\r\n    ];\r\n\r\n    for(let i = 0; i < 4; i++) {\r\n        let row = startPoints[i].row;\r\n        let col = startPoints[i].col;\r\n        let dr = move[i][0];\r\n        let dc = move[i][1];\r\n        let count = 0;\r\n        let length = Math.max(endPoints[i].row - startPoints[i].row, endPoints[i].col - startPoints[i].col) + 1;\r\n\r\n        for(let j = 0; j < length; j++) {\r\n            if(board[row][col] === board[previousStonePosition.row][previousStonePosition.col]) {\r\n                count++;\r\n            } else {\r\n                count = 0;\r\n            }\r\n\r\n            if(count === 5) {\r\n                return board[previousStonePosition.row][previousStonePosition.col];\r\n            } else {\r\n                row += dr;\r\n                col += dc;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}